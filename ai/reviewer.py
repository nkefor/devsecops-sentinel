"""AI self-review module for validating generated fixes."""
from typing import Optional, Tuple, List
from ai.base import BaseAIProvider
from models.vulnerability import Vulnerability


class AIReviewer:
    """
    AI-powered code review system.

    Uses a second AI call to validate generated fixes before creating PRs.
    This helps catch incorrect or potentially harmful fixes.
    """

    def __init__(self, providers: List[BaseAIProvider], enabled: bool = True):
        """
        Initialize the AI reviewer.

        Args:
            providers: List of available AI providers (will use first available)
            enabled: Whether self-review is enabled
        """
        self.providers = providers
        self.enabled = enabled
        self._reviewer: Optional[BaseAIProvider] = None

        # Find first available provider for review
        for provider in providers:
            if provider.is_available():
                self._reviewer = provider
                break

    def is_available(self) -> bool:
        """Check if review capability is available."""
        return self.enabled and self._reviewer is not None

    def review(
        self,
        original_code: str,
        fixed_code: str,
        vulnerability: Vulnerability,
        generator_name: str = ""
    ) -> Tuple[bool, str]:
        """
        Review a generated fix for correctness and safety.

        Args:
            original_code: The original vulnerable code
            fixed_code: The AI-generated fix
            vulnerability: The vulnerability being fixed
            generator_name: Name of the AI that generated the fix

        Returns:
            Tuple of (is_approved, review_summary)
        """
        if not self.enabled:
            return (True, "Self-review disabled")

        if not self.is_available():
            print("[AIReviewer] Warning: No AI provider available for review, auto-approving")
            return (True, "No reviewer available - auto-approved")

        print(f"    [Review] Validating fix with {self._reviewer.get_name()}...")

        # Perform the review
        is_approved, comments = self._reviewer.review_fix(
            original_code,
            fixed_code,
            vulnerability
        )

        # Build summary
        status = "APPROVED" if is_approved else "REJECTED"
        summary = f"""
### AI Self-Review ({self._reviewer.get_name()})

**Status:** {status}
**Generated by:** {generator_name or "Unknown"}
**Reviewed by:** {self._reviewer.get_name()}

**Review Comments:**
{comments}
"""

        if not is_approved:
            print(f"    [Review] Fix REJECTED: {comments[:100]}...")
        else:
            print(f"    [Review] Fix APPROVED")

        return (is_approved, summary)

    def quick_validate(self, fixed_code: str, vulnerability: Vulnerability) -> bool:
        """
        Perform quick syntax and sanity validation without full AI review.

        Args:
            fixed_code: The generated fix
            vulnerability: The vulnerability context

        Returns:
            True if basic validation passes
        """
        # Check for empty fix
        if not fixed_code or len(fixed_code.strip()) < 10:
            return False

        # Check for obvious issues
        dangerous_patterns = [
            "DELETE FROM",
            "DROP TABLE",
            "rm -rf",
            "format c:",
            ":(){ :|:& };:",  # Fork bomb
        ]

        for pattern in dangerous_patterns:
            if pattern.lower() in fixed_code.lower():
                return False

        # Check that the fix still contains key resource identifiers
        # (basic check that it didn't completely remove the resource)
        if vulnerability.resource:
            resource_parts = vulnerability.resource.split(".")
            if len(resource_parts) >= 2:
                resource_type = resource_parts[0]
                resource_name = resource_parts[-1]
                if resource_type not in fixed_code or resource_name not in fixed_code:
                    # Resource might have been removed entirely
                    return False

        return True


class ReviewResult:
    """Container for review results."""

    def __init__(
        self,
        is_approved: bool,
        summary: str,
        reviewer_name: str = "",
        quick_validation_passed: bool = True
    ):
        self.is_approved = is_approved
        self.summary = summary
        self.reviewer_name = reviewer_name
        self.quick_validation_passed = quick_validation_passed

    @property
    def should_proceed(self) -> bool:
        """Determine if the fix should be used."""
        return self.is_approved and self.quick_validation_passed

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "is_approved": self.is_approved,
            "summary": self.summary,
            "reviewer_name": self.reviewer_name,
            "quick_validation_passed": self.quick_validation_passed,
            "should_proceed": self.should_proceed
        }
